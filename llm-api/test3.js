import ollama from 'ollama';
import axios from 'axios';

// const message = { role: 'user', content: "There is no dearth of content on the web for explaining multi threading concepts but the purpose of this article is to internalise those concepts by using practical real-life examples. Multithreading offers a powerful way to boost application performance by running multiple tasks simultaneously. However, this added power comes with a layer of complexity. Unlike single-threaded programs where execution follows a clear path, multithreaded programs involve multiple threads that can access shared resources and data concurrently. This is where multithreading design patterns come in — proven approaches to navigate the complexities of concurrent programming. This article will delve deeper into several key multithreading design patterns, explaining their purpose and benefits, along with practical examples to illustrate their real-world application. 1. Producer Consumer Pattern The Producer-Consumer pattern involves two types of threads: producers that generate data and consumers that process it. They communicate through a shared buffer. Use Cases: Processing data in batches: Download large files in chunks and process them piece by piece. Image/video processing: Pre-process images for a website while the main thread displays content. Task Queues: Handle user requests asynchronously, preventing the main thread from blocking. Real life Examples: The potter (producer) creates beautiful mugs and bowls (data). They place their finished work on a shelf (shared queue) in the shop. The salesperson (consumer) then takes the pottery from the shelf whenever a customer wants to buy something (needs the data). This pattern is handy when you have jobs with two separate parts, like making something (producing) and then selling it (consuming). Imagine a bakery with a baker (producer) making bread and a salesperson (consumer) selling it. They don’t directly interact. The baker puts bread on a tray (shared queue). The salesperson takes bread from the tray when needed. This pattern is useful when tasks have clear production and consumption stages, like processing data in batches. 2. Thread Pool Pattern The Thread Pool pattern maintains a pool of pre-created worker threads ready to tackle tasks. This avoids the overhead of creating and destroying threads for each short-lived job, maximizing efficiency. Use Cases: Handling network requests: A pool of threads can efficiently process incoming requests from multiple clients concurrently. Background tasks: Offload non-critical tasks like image resizing or data compression to the thread pool without impacting the main program’s responsiveness. Batch processing: Execute numerous short-lived tasks in parallel, like sending emails or updating databases. Real life Examples: Picture a car wash with a team of prepped car washers (thread pool). Cars (tasks) arrive, and a washer becomes available to clean them. This avoids creating new washers for every car, saving time. Use this pattern when you have many short tasks, like processing images, to optimize resource usage. Imagine a computer repair shop with a team of technicians (thread pool) ready to assist customers (tasks). Customers arrive, and an available technician helps them. This avoids hiring new technicians for every customer, saving time. Use this pattern when you have many short tasks, like processing network requests, to optimize resource usage. 3. Futures and Promises Pattern The Futures and Promises pattern decouples long-running tasks from the main thread. A promise acts as a placeholder for the eventual result, while a future provides a way to access it once it’s available. This allows the main thread to continue execution without blocking. Use Cases: Asynchronous operations: Initiate tasks like downloading large files or performing complex calculations without stalling the main thread. Background processing: Offload time-consuming computations to a separate thread and retrieve the results later through the future object. Chained operations: Perform multiple asynchronous tasks sequentially, waiting for the previous one to finish before starting the next. Real life Example: Think of ordering a pizza online (submit a task). You place the order and receive a confirmation email (promise) saying it’ll be ready soon. Later, you check your email (future) to see if the pizza is ready (get the result). This pattern is useful for tasks that take a while, like generating a big report, so you can keep using your computer (main program) while you wait. 4. Monitor Object Pattern The Monitor Object pattern acts as a gatekeeper for shared resources in multithreading. It ensures only one thread can access a critical section of code (like updating a bank account balance) at a time, preventing race conditions and data corruption. Use Cases: Shared data protection: Safeguard critical data structures like account balances, inventory levels, or any resource that needs exclusive access for updates. Thread synchronization: Control access to shared resources in scenarios where multiple threads might try to modify data simultaneously, preventing unexpected outcomes. Coordinating access: Manage access to hardware resources like printers or network connections, ensuring only one thread interacts with them at a time. Real life Example: Imagine a single microphone (shared resource) in a meeting. Only one person (thread) can speak at a time using the monitor (critical section). This ensures everyone is heard clearly and avoids talking over each other (race conditions). Use this pattern to protect shared data from conflicting updates, like managing a bank account balance. I would be publishing a follow up of this article with more design patterns on multithreading including the Read lock write pattern, Active object pattern and Barrier Pattern. summarize this text for me and list bullet point to explain to me." }

// const startTime = Date.now();
// const response = await ollama.chat({ model: 'gemma2:2b', messages: [message], stream: true });
// const endTime = Date.now();
// for await (const part of response) {
//   process.stdout.write(part.message.content)
// }
// console.log("Response time: ", endTime - startTime);
// const list = await ollama.pull({model: 'gemma2:2b'});
// console.log(list);

const response1 = await axios.get('http://127.0.0.1:11434/');
console.log(response1.status);